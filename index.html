<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–°æ˜¥ç”»å· - æœ€ç»ˆç¨³å®šç‰ˆ (è§„åˆ™æœ€ä¸¥æ ¼)</title>
    <style>
        :root {
            --primary-red: #8B0000;
            --gold: #FFD700;
            --bg-color: #2c2c2c;
            --tile-size: 80px; 
            --tab-size: 12px;
            --render-size: calc(var(--tile-size) + var(--tab-size) * 2);
            
            --cols: 7;         
            --rows: 5;         
            --board-w: calc(var(--cols) * var(--tile-size)); 
            --board-h: calc(var(--rows) * var(--tile-size));
        }

        body {
            font-family: 'Microsoft YaHei', serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            height: 100vh;
            user-select: none; 
            overflow: hidden;
        }

        #drag-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            z-index: 9999;
        }

        /* é¡¶éƒ¨UIåŒº */
        .header {
            width: 100%; max-width: 900px; display: flex;
            justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, #4a1212, #2a0a0a);
            padding: 10px 20px; border: 2px solid var(--gold);
            border-radius: 10px; margin-bottom: 20px;
            box-sizing: border-box; flex-shrink: 0;
        }

        .title { font-size: 24px; color: var(--gold); font-weight: bold; }
        .status-bar { display: flex; gap: 20px; font-size: 18px; }
        .btn-group { display: flex; gap: 10px; }
        .btn {
            background: linear-gradient(to bottom, #f3dba9, #dcb365);
            border: 1px solid #5c3c12; padding: 5px 15px; cursor: pointer;
            font-weight: bold; color: #3e2706; border-radius: 4px;
        }
        #fileInput { display: none; }

        .game-container {
            display: flex; gap: 40px; position: relative;
            justify-content: center; align-items: flex-start; 
        }

        .puzzle-board {
            display: grid;
            grid-template-columns: repeat(var(--cols), var(--tile-size));
            grid-template-rows: repeat(var(--rows), var(--tile-size));
            gap: 0; 
            background-color: rgba(0, 0, 0, 0.5);
            border: 5px solid var(--gold);
            position: relative;
            width: var(--board-w);
            height: var(--board-h);
            flex-shrink: 0;
            z-index: 1;
            overflow: visible; 
        }

        .grid-slot {
            width: var(--tile-size); height: var(--tile-size);
            border: 1px dashed rgba(255, 255, 255, 0.15); 
            box-sizing: border-box; pointer-events: none; 
            z-index: 2; 
        }

        .preview-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #dcb365; background-size: cover; 
            opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 5; 
        }
        .preview-overlay.show { opacity: 0.8; }

        .piece-dock {
            width: 160px; height: calc(var(--board-h) + 20px);
            background: rgba(0,0,0,0.3); border: 2px solid #555;
            overflow-y: auto; padding: 10px; display: flex;
            flex-direction: column; align-items: center; gap: 5px; 
            flex-shrink: 0; z-index: 10;
        }

        .puzzle-group {
            position: absolute; z-index: 50; cursor: grab;
            pointer-events: auto; transition: none; 
        }
        .puzzle-group.dragging {
            z-index: 9999; transform: scale(1.05); transition: none;
        }
        
        .puzzle-piece {
            width: var(--render-size); height: var(--render-size);
            background-color: transparent; 
            background-size: var(--board-w) var(--board-h); 
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
            cursor: grab;
            position: relative; z-index: 1; flex-shrink: 0;
            pointer-events: auto; user-select: none;
            -webkit-user-drag: none;
            transition: transform 0.2s, filter 0.2s;
        }
        
        .puzzle-group .puzzle-piece {
            position: absolute; z-index: 1; margin: 0; 
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
        }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none;
            justify-content: center; align-items: center; z-index: 10000;
        }
        .modal-content {
            background: #fff; color: #333; padding: 30px; border-radius: 10px;
            text-align: center; border: 5px solid var(--primary-red); max-width: 400px;
        }
        .star-result { font-size: 30px; color: var(--gold); margin: 10px 0; }
        
        /* åŠ¨ç”»æ—¶é•¿ä¸¥æ ¼æŒ‰æ–‡æ¡£è¦æ±‚è®¾ç½®ä¸º 1s */
        .flying-back {
            transition: all 1s ease-in-out !important; 
        }
    </style>
</head>
<body>

    <div id="drag-layer"></div>

    <div class="header">
        <div class="title">æ–°æ˜¥ç”»å· - æœ€ç»ˆç¨³å®šç‰ˆ</div>
        <div class="status-bar">
            <span id="timerDisplay">â± 00:00</span>
            <span id="starDisplay">â­â­â­</span>
        </div>
        <div class="btn-group">
            <input type="file" id="fileInput" accept="image/*" onchange="handleImageUpload(event)">
            <button class="btn" onclick="document.getElementById('fileInput').click()">ğŸ“‚ é€‰æ‹©å›¾ç‰‡</button>
            <button class="btn" id="viewOriginalBtn" onmousedown="showOriginal()" onmouseup="hideOriginal()" onmouseleave="hideOriginal()">ğŸ‘€ çœ‹åŸå›¾</button>
            <button class="btn" onclick="initGame()">ğŸ”„ é‡ç½®</button>
        </div>
    </div>

    <div class="game-container">
        <div class="puzzle-board" id="board">
            <div class="preview-overlay" id="previewOverlay"></div>
        </div>

        <div class="piece-dock" id="dock"></div>
    </div>

    <div class="modal" id="resultModal">
        <div class="modal-content">
            <h2 id="resultTitle">æŒ‘æˆ˜æˆåŠŸï¼</h2>
            <div class="star-result" id="resultStars">â­â­â­</div>
            <p id="resultTime">ç”¨æ—¶: 1åˆ†20ç§’</p>
            <p id="resultDesc">æ–°çºªå½•ï¼</p>
            <button class="btn" onclick="closeModal()">ç¡®å®š</button>
        </div>
    </div>

    <script>
        const COLS = 7; 
        const ROWS = 5; 
        const TILE_SIZE = 80;
        const TAB_SIZE = 12; 
        const GROUP_OFFSET = -TAB_SIZE; 
        
        const PLACED_PIECES_MAP = new Map(); 

        let currentImgUrl = './image.jpg'; 
        const FALLBACK_IMG = 'https://picsum.photos/560/400';

        let pieces = []; 
        let isGaming = false;
        let timerInterval = null;
        let secondsElapsed = 0;
        
        let verticalEdges = [];   
        let horizontalEdges = []; 

        const boardEl = document.getElementById('board');
        const dockEl = document.getElementById('dock');
        const dragLayer = document.getElementById('drag-layer');
        const timerEl = document.getElementById('timerDisplay');
        const starEl = document.getElementById('starDisplay');
        const modalEl = document.getElementById('resultModal');
        const overlayEl = document.getElementById('previewOverlay');
        
        window.onload = () => {
            checkDefaultImage();
            createGrid();
        };
        
        function checkDefaultImage() {
            const img = new Image();
            img.src = currentImgUrl;
            img.onload = () => initGame(); 
            img.onerror = () => {
                currentImgUrl = FALLBACK_IMG; 
                initGame();
            };
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                currentImgUrl = e.target.result;
                initGame(); 
            }
            reader.readAsDataURL(file);
        }

        function createGrid() {
            boardEl.innerHTML = '';
            boardEl.appendChild(overlayEl); 
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    let slot = document.createElement('div');
                    slot.className = 'grid-slot';
                    boardEl.appendChild(slot);
                }
            }
        }
        
        function generatePuzzleShapes() {
            verticalEdges = [];
            horizontalEdges = [];
            for (let r = 0; r < ROWS; r++) {
                let rowEdges = [];
                for (let c = 0; c <= COLS; c++) {
                    rowEdges.push((c === 0 || c === COLS) ? 0 : (Math.random() > 0.5 ? 1 : -1));
                }
                verticalEdges.push(rowEdges);
            }
            for (let r = 0; r <= ROWS; r++) {
                let rowEdges = [];
                for (let c = 0; c < COLS; c++) {
                    rowEdges.push((r === 0 || r === ROWS) ? 0 : (Math.random() > 0.5 ? 1 : -1));
                }
                horizontalEdges.push(rowEdges);
            }
        }

        function initGame() {
            isGaming = true;
            secondsElapsed = 0;
            pieces = [];
            PLACED_PIECES_MAP.clear();
            
            overlayEl.style.backgroundImage = `url('${currentImgUrl}')`;
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateTimerView();

            dockEl.innerHTML = '';
            document.querySelectorAll('.puzzle-piece, .puzzle-group').forEach(p => p.remove());

            generatePuzzleShapes();

            let tempPieces = [];
            const TOTAL_PIECES = COLS * ROWS; 
            for (let i = 0; i < TOTAL_PIECES; i++) {
                const targetX = i % COLS;
                const targetY = Math.floor(i / COLS);
                
                const shapes = {
                    top: horizontalEdges[targetY][targetX],
                    right: verticalEdges[targetY][targetX+1],
                    bottom: horizontalEdges[targetY+1][targetX],
                    left: verticalEdges[targetY][targetX]
                };

                tempPieces.push({
                    id: i,
                    targetX: targetX,
                    targetY: targetY,
                    currentX: -1, 
                    currentY: -1, 
                    isPlaced: false,
                    shapes: shapes,
                    el: null,          
                    groupEl: null,     
                    groupAnchorX: -1,  
                    groupAnchorY: -1,  
                });
            }

            // è§„åˆ™è¦æ±‚ï¼šæ¯æ¬¡è¿›å…¥æŒ‘æˆ˜ï¼Œå°†35å¼ æ‹¼å›¾å—éšæœºæ´—ç‰Œï¼ŒæŒ‰æ´—ç‰Œåçš„é¡ºåºä»ä¸Šåˆ°ä¸‹å±•ç¤º
            shuffleArray(tempPieces);
            tempPieces.forEach(p => createPieceElement(p));
        }

        // --- SVG Path è¾…åŠ©å‡½æ•° ---
        function getPiecePath(top, right, bottom, left) { 
            const S = TILE_SIZE; 
            const T = TAB_SIZE;
            let path = `M ${T} ${T} `; 
            if (top === 0) { path += `L ${T+S} ${T} `; } else { path += drawHorizontalSide(S, T, (top === -1) ? -1 : 1); }
            if (right === 0) { path += `L ${T+S} ${T+S} `; } else { path += drawVerticalSide(S, T, (right === 1) ? 1 : -1); }
            if (bottom === 0) { path += `L ${T} ${T+S} `; } else { path += drawHorizontalSideBack(S, T, (bottom === 1) ? 1 : -1); }
            if (left === 0) { path += `L ${T} ${T} `; } else { path += drawVerticalSideBack(S, T, (left === -1) ? -1 : 1); }
            return path + "Z";
        }
        
        function drawHorizontalSide(S, T, sign) { 
            const neck = S * 0.35; const earW = S * 0.3; 
            let p = `l ${neck} 0 `; 
            p += `c 5 ${sign*T}, ${earW-5} ${sign*T}, ${earW} 0 `; 
            p += `l ${neck} 0 `; return p; 
        }
        function drawHorizontalSideBack(S, T, sign) { 
            const neck = S * 0.35; const earW = S * 0.3; 
            let p = `l -${neck} 0 `; 
            p += `c -5 ${sign*T}, -${earW-5} ${sign*T}, -${earW} 0 `; 
            p += `l -${neck} 0 `; return p; 
        }
        function drawVerticalSide(S, T, sign) { 
            const neck = S * 0.35; const earW = S * 0.3; 
            let p = `l 0 ${neck} `; 
            p += `c ${sign*T} 5, ${sign*T} ${earW-5}, 0 ${earW} `; 
            p += `l 0 ${neck} `; return p; 
        }
        
        function drawVerticalSideBack(S, T, sign) {
            const neck = S * 0.35;
            const earW = S * 0.3;
            let p = `l 0 -${neck} `; 
            p += `c ${sign*T} -5, ${sign*T} -${earW-5}, 0 -${earW} `; 
            p += `l 0 -${neck} `; 
            return p;
        }

        function createPieceElement(pieceData) {
            const el = document.createElement('div');
            el.className = 'puzzle-piece';
            el.id = 'piece_' + pieceData.id;
            pieceData.el = el;
            
            el.style.backgroundImage = `url('${currentImgUrl}')`;
            
            const pathStr = getPiecePath(pieceData.shapes.top, pieceData.shapes.right, pieceData.shapes.bottom, pieceData.shapes.left);
            el.style.clipPath = `path('${pathStr}')`;
            el.style.webkitClipPath = `path('${pathStr}')`;

            const bgX = -(pieceData.targetX * TILE_SIZE) + TAB_SIZE;
            const bgY = -(pieceData.targetY * TILE_SIZE) + TAB_SIZE;
            el.style.backgroundPosition = `${bgX}px ${bgY}px`;

            el.onmousedown = (e) => handleDragStart(e, el, pieceData);
            
            dockEl.appendChild(el);
            pieces.push({el: el, data: pieceData});
        }
        
        // --- ç»„åˆæ‹¼å›¾å—é€»è¾‘ ---
        
        function updatePieceMap(pieceObj, action) {
            const key = `${pieceObj.currentX},${pieceObj.currentY}`;
            if (action === 'add') {
                PLACED_PIECES_MAP.set(key, pieceObj);
            } else if (action === 'remove') {
                PLACED_PIECES_MAP.delete(key);
            }
        }

        function createGroup(pieceObj) {
            const groupEl = document.createElement('div');
            groupEl.className = 'puzzle-group';
            
            pieceObj.groupEl = groupEl;
            pieceObj.groupAnchorX = pieceObj.currentX;
            pieceObj.groupAnchorY = pieceObj.currentY;
            
            groupEl.style.left = (pieceObj.currentX * TILE_SIZE + GROUP_OFFSET) + 'px';
            groupEl.style.top = (pieceObj.currentY * TILE_SIZE + GROUP_OFFSET) + 'px';
            
            boardEl.appendChild(groupEl);
            movePieceToGroup(pieceObj, groupEl, pieceObj.groupAnchorX, pieceObj.groupAnchorY);
            
            return groupEl;
        }
        
        function movePieceToGroup(pieceObj, groupEl, anchorX, anchorY) {
            const pieceEl = pieceObj.el;
            
            const relativeX = (pieceObj.currentX - anchorX) * TILE_SIZE;
            const relativeY = (pieceObj.currentY - anchorY) * TILE_SIZE;

            pieceEl.classList.remove('flying-back');
            groupEl.appendChild(pieceEl);
            
            pieceEl.style.left = relativeX + 'px';
            pieceEl.style.top = relativeY + 'px';

            pieceObj.groupEl = groupEl;
            pieceObj.groupAnchorX = anchorX;
            pieceObj.groupAnchorY = anchorY;
        }
        
        function unionGroups(anchorGroupObj, targetGroupObj) {
            const anchorGroupEl = anchorGroupObj.groupEl;
            const targetGroupEl = targetGroupObj.groupEl;
            
            if (anchorGroupEl === targetGroupEl) return; 

            const anchorX = anchorGroupObj.groupAnchorX;
            const anchorY = anchorGroupObj.groupAnchorY;
            
            const piecesToMove = pieces.filter(p => p.data.groupEl === targetGroupEl);
            
            piecesToMove.forEach(p => {
                movePieceToGroup(p.data, anchorGroupEl, anchorX, anchorY);
            });
            
            targetGroupEl.remove();
        }
        
        function checkAndMergeByPosition(pieceObj) {
            const neighbors = [
                { dx: 0, dy: -1 }, 
                { dx: 1, dy: 0 },  
                { dx: 0, dy: 1 },  
                { dx: -1, dy: 0 }  
            ];

            let anchorGroup = pieceObj; 
            let groupsToMerge = []; 

            const currentX = pieceObj.currentX;
            const currentY = pieceObj.currentY;

            for (const { dx, dy } of neighbors) {
                const neighborX = currentX + dx;
                const neighborY = currentY + dy;
                
                const neighborObj = PLACED_PIECES_MAP.get(`${neighborX},${neighborY}`);

                if (neighborObj) {
                    if (pieceObj.groupEl === neighborObj.groupEl) {
                        continue;
                    }

                    const requiredTargetDX = pieceObj.targetX - neighborObj.targetX;
                    const requiredTargetDY = pieceObj.targetY - neighborObj.targetY;
                    
                    if (requiredTargetDX === -dx && requiredTargetDY === -dy) {
                        
                        const neighborGroupAnchor = pieces.find(p => p.data.groupEl === neighborObj.groupEl).data;
                        
                        if (groupsToMerge.indexOf(neighborGroupAnchor) === -1) {
                            groupsToMerge.push(neighborGroupAnchor);
                        }
                        
                        if (neighborObj.groupAnchorY < anchorGroup.groupAnchorY ||
                            (neighborObj.groupAnchorY === anchorGroup.groupAnchorY && neighborObj.groupAnchorX < anchorGroup.groupAnchorX)) {
                            
                            anchorGroup = neighborObj;
                        }
                    }
                }
            }
            
            groupsToMerge.push(pieceObj); 
            const finalAnchorPiece = pieces.find(p => p.data.groupEl === anchorGroup.groupEl).data;

            groupsToMerge.forEach(p => {
                if (p.groupEl !== finalAnchorPiece.groupEl) {
                    unionGroups(finalAnchorPiece, p);
                }
            });
            
            checkExternalMerges(finalAnchorPiece);

            checkWin();
        }
        
        function checkExternalMerges(groupAnchorPiece) {
             const piecesInGroup = pieces.filter(p => p.data.groupEl === groupAnchorPiece.groupEl);

             piecesInGroup.forEach(p => {
                 const neighbors = [
                    { dx: 0, dy: -1 }, 
                    { dx: 1, dy: 0 },  
                    { dx: 0, dy: 1 },  
                    { dx: -1, dy: 0 } 
                ];
                
                const currentX = p.data.currentX;
                const currentY = p.data.currentY;
                
                for (const { dx, dy } of neighbors) {
                    const neighborX = currentX + dx;
                    const neighborY = currentY + dy;
                    
                    const neighborObj = PLACED_PIECES_MAP.get(`${neighborX},${neighborY}`);
                    
                    if (neighborObj && neighborObj.groupEl !== groupAnchorPiece.groupEl) {
                        
                        const requiredTargetDX = p.data.targetX - neighborObj.targetX;
                        const requiredTargetDY = p.data.targetY - neighborObj.targetY;
                        
                        if (requiredTargetDX === -dx && requiredTargetDY === -dy) {
                            
                            let anchorPiece = groupAnchorPiece;
                            let targetPiece = pieces.find(p => p.data.groupEl === neighborObj.groupEl).data;
                            
                            if (neighborObj.groupAnchorY < groupAnchorPiece.groupAnchorY ||
                                (neighborObj.groupAnchorY === groupAnchorPiece.groupAnchorY && neighborObj.groupAnchorX < groupAnchorPiece.groupAnchorX)) {
                                
                                anchorPiece = neighborObj;
                                targetPiece = groupAnchorPiece;
                            }
                            
                            unionGroups(anchorPiece, targetPiece);
                            checkExternalMerges(anchorPiece);
                            return; 
                        }
                    }
                }
             });
        }
        
        // --- æ‹–æ‹½æ ¸å¿ƒé€»è¾‘ ---
        let draggedEl = null;
        let dragOffset = {x:0, y:0};

        function handleDragStart(e, el, pieceData) {
            if (!isGaming) return;
            e.preventDefault();
            
            let elementToDrag = pieceData.isPlaced ? pieceData.groupEl : el;
            
            draggedEl = elementToDrag;
            draggedEl.classList.add('dragging');

            const rect = elementToDrag.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;

            dragLayer.appendChild(elementToDrag); 

            elementToDrag.style.left = (e.clientX - dragOffset.x) + 'px';
            elementToDrag.style.top = (e.clientY - dragOffset.y) + 'px';

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function onMouseMove(e) {
           e.preventDefault(); 
           if (!draggedEl) return;
           draggedEl.style.left = (e.clientX - dragOffset.x) + 'px';
           draggedEl.style.top = (e.clientY - dragOffset.y) + 'px';
        }

        function onMouseUp(e) {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            
            if (!draggedEl) return;
            draggedEl.classList.remove('dragging');

            const boardRect = boardEl.getBoundingClientRect();
            const elementRect = draggedEl.getBoundingClientRect();
            
            const isGroup = draggedEl.classList.contains('puzzle-group');
            
            let placementSuccessful = false;
            
            // 1. è®¡ç®—å…ƒç´ ç›¸å¯¹äºæ£‹ç›˜çš„åç§» (Group/Piece çš„ bounding box å·¦ä¸Šè§’)
            const boardRelativeLeft = elementRect.left - boardRect.left;
            const boardRelativeTop = elementRect.top - boardRect.top;
            
            // 2. ç§»é™¤ Group/Piece çš„ GROUP_OFFSET å¾—åˆ°é”šç‚¹/ä¸­å¿ƒæ–¹å—çš„ç½‘æ ¼å·¦ä¸Šè§’ä½ç½®
            const anchorGridLeft = boardRelativeLeft - GROUP_OFFSET; 
            const anchorGridTop = boardRelativeTop - GROUP_OFFSET;
            
            // 3. èˆå…¥åˆ°æœ€è¿‘çš„ç½‘æ ¼ç´¢å¼• (snap target)ï¼Œå®ç°ç²¾ç¡®å¯¹é½
            const snapX = Math.round(anchorGridLeft / TILE_SIZE);
            const snapY = Math.round(anchorGridTop / TILE_SIZE);

            // 4. è¾¹ç•Œé¢„æ£€æŸ¥ï¼šå¸é™„ç›®æ ‡å¿…é¡»åœ¨æ£‹ç›˜çš„æœ‰æ•ˆç½‘æ ¼å†…
            if (snapX >= 0 && snapX < COLS && snapY >= 0 && snapY < ROWS) {
                
                if (isGroup) {
                    
                    const anchorPiece = pieces.find(p => p.data.groupEl === draggedEl).data;
                    const piecesInGroup = pieces.filter(p => p.data.groupEl === draggedEl);

                    const offsetX = snapX - anchorPiece.groupAnchorX;
                    const offsetY = snapY - anchorPiece.groupAnchorY;

                    let collision = false;
                    let isWithinBounds = true;
                    
                    // **ä¸¥æ ¼è¾¹ç•Œä¸ç¢°æ’æ£€æµ‹ - ç»„åˆå—**ï¼šæ£€æŸ¥æ‰€æœ‰æ–¹å—çš„æ–°ä½ç½®
                    for (const p of piecesInGroup) {
                        const newPieceX = p.data.currentX + offsetX;
                        const newPieceY = p.data.currentY + offsetY;
                        
                        // ä¸¥æ ¼è¾¹ç•Œæ£€æŸ¥ï¼šä»»ä½•ç¢ç‰‡è¶…å‡ºæ£‹ç›˜åˆ™æ”¾ç½®å¤±è´¥
                        if (newPieceX < 0 || newPieceX >= COLS || newPieceY < 0 || newPieceY >= ROWS) {
                            isWithinBounds = false;
                            break;
                        }

                        // ç¢°æ’æ£€æµ‹ï¼šç›®æ ‡ä½ç½®æ˜¯å¦è¢«å…¶ä»–ç»„å æ®
                        const occupyingPiece = PLACED_PIECES_MAP.get(`${newPieceX},${newPieceY}`);

                        if (occupyingPiece && occupyingPiece.groupEl !== draggedEl) {
                            collision = true;
                            break;
                        }
                    }

                    if (isWithinBounds && !collision) {
                        placeGroup(draggedEl, snapX, snapY);
                        placementSuccessful = true;
                    }

                } else {
                    // **å•ä¸ªç¢ç‰‡**
                    if (!PLACED_PIECES_MAP.has(`${snapX},${snapY}`)) {
                        const pieceObj = pieces.find(p => p.el === draggedEl).data;
                        placePiece(pieceObj, snapX, snapY);
                        placementSuccessful = true;
                    }
                }
            } 
            
            // æ”¾ç½®å¤±è´¥å¤„ç† (æœªèƒ½å¸é™„åˆ°æœ‰æ•ˆç½‘æ ¼ï¼Œæˆ–å¸é™„åç¢°æ’/è¶Šç•Œ)
            if (!placementSuccessful) {
                if (isGroup) {
                    // é£å›åŸä½ (ä¸Šä¸€æœ‰æ•ˆå¸é™„ç‚¹)
                    const currentBoardX = elementRect.left - boardRect.left;
                    const currentBoardY = elementRect.top - boardRect.top;

                    // 1. åæ ‡åŒæ­¥ï¼Œé˜²æ­¢è·³è·ƒ
                    draggedEl.style.transition = 'none';
                    boardEl.appendChild(draggedEl); 
                    draggedEl.style.left = currentBoardX + 'px';
                    draggedEl.style.top = currentBoardY + 'px';
                    
                    // 2. å»¶è¿Ÿå¯åŠ¨è¿”å›åŠ¨ç”»
                    setTimeout(() => {
                        draggedEl.style.transition = 'all 1s ease-in-out';
                        returnGroupToPrevious(draggedEl);
                    }, 10);
                } else {
                    // é£å› Dock (å·²ä¿®å¤è·³è·ƒé—®é¢˜)
                    returnToDock(draggedEl);
                }
            }
            draggedEl = null;
        }

        function placePiece(pieceObj, gridX, gridY) {
            updatePieceMap(pieceObj, 'remove'); 
            
            pieceObj.isPlaced = true;
            pieceObj.currentX = gridX;
            pieceObj.currentY = gridY;
            
            updatePieceMap(pieceObj, 'add');

            createGroup(pieceObj);
            
            checkAndMergeByPosition(pieceObj);
        }
        
        function placeGroup(groupEl, gridX, gridY) {
            const anchorPiece = pieces.find(p => p.data.groupEl === groupEl).data;
            
            const piecesInGroup = pieces.filter(p => p.data.groupEl === groupEl);
            piecesInGroup.forEach(p => updatePieceMap(p.data, 'remove')); 

            const offsetX = gridX - anchorPiece.groupAnchorX;
            const offsetY = gridY - anchorPiece.groupAnchorY;
            
            piecesInGroup.forEach(p => {
                p.data.currentX = p.data.currentX + offsetX;
                p.data.currentY = p.data.currentY + offsetY;
                p.data.isPlaced = true;
                
                if (p.data === anchorPiece) {
                    p.data.groupAnchorX = gridX;
                    p.data.groupAnchorY = gridY;
                }
                updatePieceMap(p.data, 'add'); 
            });
            
            boardEl.appendChild(groupEl); 

            groupEl.style.left = (anchorPiece.groupAnchorX * TILE_SIZE + GROUP_OFFSET) + 'px';
            groupEl.style.top = (anchorPiece.groupAnchorY * TILE_SIZE + GROUP_OFFSET) + 'px';
            
            checkExternalMerges(anchorPiece);
            
            checkWin();
        }

        // **å·²ä¿®æ­£ï¼šç¢ç‰‡è¿”å› Dock çš„é€»è¾‘ï¼Œæ¶ˆé™¤è§†è§‰è·³è·ƒ**
        function returnToDock(el) {
            const id = parseInt(el.id.split('_')[1]);
            const pieceObj = pieces.find(p => p.data.id === id).data;
            
            // 1. æ¸…ç†æ¸¸æˆçŠ¶æ€
            updatePieceMap(pieceObj, 'remove');
            pieceObj.isPlaced = false;

            // 2. ç¡®å®šç›®æ ‡ä½ç½®ï¼šä½¿ç”¨å ä½ç¬¦ (placeholder) æ¥è·å–å…ƒç´ åœ¨æµå¼å¸ƒå±€ä¸­çš„æœ€ç»ˆå±å¹•åæ ‡
            const currentRect = el.getBoundingClientRect(); // å½“å‰å±å¹•ä½ç½®
            const placeholder = document.createElement('div');
            // å ä½ç¬¦å¿…é¡»æ¨¡ä»¿ piece çš„å°ºå¯¸å’Œå¤–è¾¹è·ï¼Œä»¥ä¾¿è®¡ç®—å‡ºæ­£ç¡®çš„ç›®æ ‡ä½ç½®
            placeholder.style.width = el.offsetWidth + 'px';
            placeholder.style.height = el.offsetHeight + 'px';
            placeholder.style.visibility = 'hidden'; 
            dockEl.appendChild(placeholder); // æ”¾åœ¨ dock çš„æœ«å°¾ (æ­£ç¡®çš„ç›®æ ‡ä½ç½®)
            const targetRect = placeholder.getBoundingClientRect(); 

            // 3. åŠ¨ç”»å‡†å¤‡ï¼šç¡®ä¿å…ƒç´ åœ¨ dragLayerï¼Œè®¾ç½®ç²¾ç¡®çš„èµ·å§‹ç»å¯¹ä½ç½®
            el.style.transition = 'none'; // ç¦ç”¨ç¬é—´çš„ CSS åŠ¨ç”»
            el.style.position = 'absolute'; 
            el.style.left = currentRect.left + 'px';
            el.style.top = currentRect.top + 'px';
            dragLayer.appendChild(el);
            
            // 4. è§¦å‘è¿”å›åŠ¨ç”»
            setTimeout(() => {
                el.style.transition = 'all 1s ease-in-out'; // æ¢å¤åŠ¨ç”»ï¼Œæ—¶é•¿ 1s
                el.classList.add('flying-back');
                el.style.left = targetRect.left + 'px';
                el.style.top = targetRect.top + 'px';
            }, 10); 

            // 5. åŠ¨ç”»ç»“æŸåï¼Œå°†å…ƒç´ ç§»åŠ¨å› dock å¹¶æ¢å¤æµå¼å¸ƒå±€
            setTimeout(() => {
                el.classList.remove('flying-back');
                el.style.transition = 'none'; 
                
                // å°†å…ƒç´ ç§»åŠ¨åˆ°å ä½ç¬¦çš„ä½ç½® (åœ¨å ä½ç¬¦ä¹‹å‰æ’å…¥)
                dockEl.insertBefore(el, placeholder);
                placeholder.remove();

                // æ¢å¤æµå¼å¸ƒå±€çš„æ ·å¼
                el.style.position = 'relative';
                el.style.left = '0';
                el.style.top = '0';
            }, 1000); 
        }
        
        function returnGroupToPrevious(groupEl) {
            const anchorPiece = pieces.find(p => p.data.groupEl === groupEl).data;
            const prevX = anchorPiece.groupAnchorX;
            const prevY = anchorPiece.groupAnchorY; 

            groupEl.classList.add('flying-back'); 
            
            // è®¾å®šç›®æ ‡ä½ç½® (è§¦å‘ 1s åŠ¨ç”»)
            groupEl.style.left = (prevX * TILE_SIZE + GROUP_OFFSET) + 'px';
            groupEl.style.top = (prevY * TILE_SIZE + GROUP_OFFSET) + 'px';

            // åŠ¨ç”»ç»“æŸåç§»é™¤è¿‡æ¸¡
            setTimeout(() => {
                groupEl.classList.remove('flying-back');
                groupEl.style.transition = 'none'; 
            }, 1000);
        }

        // --- æ¸¸æˆçŠ¶æ€ (ä¿æŒä¸å˜) ---
        function updateTimer() {
            secondsElapsed++;
            updateTimerView();
            if (secondsElapsed > 180) { gameOver(false); }
        }

        function updateTimerView() {
            const min = Math.floor(secondsElapsed / 60);
            const sec = secondsElapsed % 60;
            timerEl.innerText = `â± ${min}:${sec < 10 ? '0'+sec : sec}`;
            if (secondsElapsed <= 120) starEl.innerText = "â­â­â­";
            else if (secondsElapsed <= 150) starEl.innerText = "â­â­";
            else if (secondsElapsed <= 180) starEl.innerText = "â­";
            else starEl.innerText = "ğŸ’”";
        }

        function showOriginal() { overlayEl.classList.add('show'); }
        function hideOriginal() { overlayEl.classList.remove('show'); }

        function checkWin() {
            const allPlaced = pieces.every(p => p.data.isPlaced);
            if (!allPlaced) return;
            const allCorrect = pieces.every(p => 
                p.data.isPlaced && 
                p.data.currentX === p.data.targetX && 
                p.data.currentY === p.data.targetY
            );
            if (allCorrect) { gameOver(true); }
        }

        function gameOver(success) {
            isGaming = false;
            clearInterval(timerInterval);
            const title = document.getElementById('resultTitle');
            const stars = document.getElementById('resultStars');
            const time = document.getElementById('resultTime');
            const desc = document.getElementById('resultDesc');
            
            if (success) {
                title.innerText = "æ­å–œï¼ç”»å·ä¿®å¤å®Œæˆ";
                title.style.color = "var(--gold)";
                time.innerText = "æœ€ç»ˆç”¨æ—¶: " + timerEl.innerText.replace('â± ', '');
                if (secondsElapsed <= 120) stars.innerText = "â­â­â­";
                else if (secondsElapsed <= 150) stars.innerText = "â­â­";
                else stars.innerText = "â­";
                desc.innerText = "å·²è®°å½•åˆ°ä¸ªäººæœ€ä½³æ¦œå•ï¼";
            } else {
                title.innerText = "æŒ‘æˆ˜å¤±è´¥";
                title.style.color = "gray";
                stars.innerText = "";
                time.innerText = "è¶…æ—¶æœªå®Œæˆ";
                desc.innerText = "è¯·é‡æ–°æŒ‘æˆ˜";
            }
            modalEl.style.display = 'flex';
        }

        function closeModal() { modalEl.style.display = 'none'; }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
    </script>
</body>
</html>