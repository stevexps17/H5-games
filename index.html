<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ–°æ˜¥ç”»å· - Safari å…¼å®¹ç‰ˆ</title>
    <style>
        :root {
            --primary-red: #8B0000;
            --gold: #FFD700;
            --bg-color: #2c2c2c;
            
            /* å˜é‡å°†åœ¨JSä¸­åŠ¨æ€è®¾ç½®ï¼Œè¿™é‡Œæ˜¯é»˜è®¤/å›é€€å€¼ */
            --tile-size: 80px; 
            --tab-size: 12px;
            --dock-width: 160px;
            
            --cols: 7;         
            --rows: 5;         
            --render-size: calc(var(--tile-size) + var(--tab-size) * 2);
            --board-w: calc(var(--cols) * var(--tile-size)); 
            --board-h: calc(var(--rows) * var(--tile-size));
        }

        body {
            font-family: 'Microsoft YaHei', serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px; 
            min-height: 100vh;
            user-select: none; 
            overflow: auto; 
        }
        
        .game-container {
            display: flex; gap: 20px; 
            flex-direction: row; 
            justify-content: center; 
            align-items: flex-start; 
            width: 100%;
            max-width: 900px;
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .puzzle-board {
                margin-bottom: 20px;
            }
            .piece-dock {
                width: 95% !important; 
                max-height: 300px; 
                overflow-y: scroll;
                flex-direction: row; 
                flex-wrap: wrap; 
                justify-content: center;
                gap: 5px;
            }
        }

        #drag-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            z-index: 9999;
        }

        .header {
            width: 100%; max-width: 900px; display: flex;
            justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, #4a1212, #2a0a0a);
            padding: 10px 10px; border: 2px solid var(--gold);
            border-radius: 10px; margin-bottom: 10px;
            box-sizing: border-box; flex-shrink: 0;
            font-size: 14px; 
        }
        .title { font-size: 18px; }
        .status-bar { display: flex; gap: 10px; font-size: 14px; }
        .btn-group { display: flex; gap: 5px; }
        .btn { padding: 5px 10px; }
        #fileInput { display: none; }

        .puzzle-board {
            display: grid;
            grid-template-columns: repeat(var(--cols), var(--tile-size));
            grid-template-rows: repeat(var(--rows), var(--tile-size));
            gap: 0; 
            background-color: rgba(0, 0, 0, 0.5);
            border: 5px solid var(--gold);
            position: relative;
            width: var(--board-w);
            height: var(--board-h);
            flex-shrink: 0;
            z-index: 1;
            overflow: visible; 
            box-sizing: content-box; 
        }

        .grid-slot {
            width: var(--tile-size); height: var(--tile-size);
            border: 1px dashed rgba(255, 255, 255, 0.15); 
            box-sizing: border-box; pointer-events: none; 
            z-index: 2; 
        }

        .piece-dock {
            width: var(--dock-width); 
            height: calc(var(--board-h) + 10px);
            background: rgba(0,0,0,0.3); border: 2px solid #555;
            overflow-y: auto; padding: 5px; 
            display: flex;
            flex-direction: column; 
            align-items: center; 
            gap: 5px; 
            flex-shrink: 0; 
            z-index: 10;
        }

        .puzzle-piece {
            width: var(--render-size); height: var(--render-size);
            touch-action: none; 
            background-size: var(--board-w) var(--board-h); 
            filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
            cursor: grab;
            position: relative; z-index: 1; flex-shrink: 0;
            pointer-events: auto; user-select: none;
            /* ç¡®ä¿ Safari/iOS ä¸Šçš„æ‹–æ‹½è¡Œä¸º */
            -webkit-user-drag: none;
        }
        
        .flying-back {
            transition: all 1s ease-in-out !important; 
        }
    </style>
</head>
<body>

    <div id="drag-layer"></div>

    <div class="header">
        <div class="title">æ–°æ˜¥ç”»å· - Safari å…¼å®¹ç‰ˆ</div>
        <div class="status-bar">
            <span id="timerDisplay">â± 00:00</span>
            <span id="starDisplay">â­â­â­</span>
        </div>
        <div class="btn-group">
            <input type="file" id="fileInput" accept="image/*" onchange="handleImageUpload(event)">
            <button class="btn" onclick="document.getElementById('fileInput').click()">ğŸ“‚ é€‰æ‹©å›¾ç‰‡</button>
            <button class="btn" id="viewOriginalBtn" onmousedown="showOriginal()" onmouseup="hideOriginal()" onmouseleave="hideOriginal()" ontouchstart="showOriginal()" ontouchend="hideOriginal()">ğŸ‘€ åŸå›¾</button>
            <button class="btn" onclick="initGame()">ğŸ”„ é‡ç½®</button>
        </div>
    </div>

    <div class="game-container">
        <div class="puzzle-board" id="board">
            <div class="preview-overlay" id="previewOverlay"></div>
        </div>

        <div class="piece-dock" id="dock"></div>
    </div>

    <div class="modal" id="resultModal">
        <div class="modal-content">
            <h2 id="resultTitle">æŒ‘æˆ˜æˆåŠŸï¼</h2>
            <div class="star-result" id="resultStars">â­â­â­</div>
            <p id="resultTime">ç”¨æ—¶: 1åˆ†20ç§’</p>
            <p id="resultDesc">æ–°çºªå½•ï¼</p>
            <button class="btn" onclick="closeModal()">ç¡®å®š</button>
        </div>
    </div>

    <script>
        const COLS = 7; 
        const ROWS = 5; 
        
        let TILE_SIZE; 
        let TAB_SIZE;
        let GROUP_OFFSET;
        
        const PLACED_PIECES_MAP = new Map(); 
        let currentImgUrl = './image.jpg'; 
        const FALLBACK_IMG = 'https://picsum.photos/560/400';

        let pieces = []; 
        let isGaming = false;
        let timerInterval = null;
        let secondsElapsed = 0;
        
        let verticalEdges = [];   
        let horizontalEdges = []; 

        const boardEl = document.getElementById('board');
        const dockEl = document.getElementById('dock');
        const dragLayer = document.getElementById('drag-layer');
        const overlayEl = document.getElementById('previewOverlay');
        const timerEl = document.getElementById('timerDisplay');
        const starEl = document.getElementById('starDisplay');
        const modalEl = document.getElementById('resultModal');

        function setupResponsiveSizes() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            
            let dynamicTileSize;

            if (vw < 768 || vw < vh) {
                dynamicTileSize = Math.floor((vw * 0.95) / COLS);
            } else {
                dynamicTileSize = Math.floor((vw * 0.75) / COLS);
            }
            
            const MAX_TILE_SIZE = 80;
            dynamicTileSize = Math.min(MAX_TILE_SIZE, dynamicTileSize);

            TILE_SIZE = dynamicTileSize;
            TAB_SIZE = Math.round(TILE_SIZE * 0.15); 
            GROUP_OFFSET = -TAB_SIZE;
            
            const DOCK_WIDTH = (TILE_SIZE + 2 * TAB_SIZE) * 2;

            document.documentElement.style.setProperty('--tile-size', TILE_SIZE + 'px');
            document.documentElement.style.setProperty('--tab-size', TAB_SIZE + 'px');
            document.documentElement.style.setProperty('--dock-width', DOCK_WIDTH + 'px');
        }

        window.onload = () => {
            setupResponsiveSizes();
            checkDefaultImage();
            createGrid();
        };

        window.onresize = () => {
             setupResponsiveSizes();
             if (isGaming) {
                 initGame();
             } else {
                 createGrid();
             }
        };
        
        function checkDefaultImage() {
            const img = new Image();
            img.onload = () => initGame(); 
            img.onerror = () => {
                currentImgUrl = FALLBACK_IMG; 
                initGame();
            };
            img.src = currentImgUrl;
        }

        // **ä¿®æ­£ï¼šå…¼å®¹ Safari çš„æ–‡ä»¶ä¸Šä¼ **
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            // ç¡®ä¿ FileReader åœ¨ Safari ä¸Šä½¿ç”¨æ­£ç¡®çš„ç±»å‹
            const reader = new FileReader();
            reader.onload = function(e) {
                currentImgUrl = e.target.result;
                initGame(); 
            }
            reader.readAsDataURL(file);
        }

        function createGrid() {
            boardEl.innerHTML = '';
            boardEl.appendChild(overlayEl); 
            boardEl.style.width = `var(--board-w)`;
            boardEl.style.height = `var(--board-h)`;
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    let slot = document.createElement('div');
                    slot.className = 'grid-slot';
                    boardEl.appendChild(slot);
                }
            }
        }
        
        function generatePuzzleShapes() { /* ä¿æŒä¸å˜ */ }
        function initGame() {
             isGaming = true;
            secondsElapsed = 0;
            pieces = [];
            PLACED_PIECES_MAP.clear();
            
            overlayEl.style.backgroundImage = `url('${currentImgUrl}')`;
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateTimerView();

            dockEl.innerHTML = '';
            document.querySelectorAll('.puzzle-piece, .puzzle-group').forEach(p => p.remove());

            generatePuzzleShapes();

            let tempPieces = [];
            const TOTAL_PIECES = COLS * ROWS; 
            for (let i = 0; i < TOTAL_PIECES; i++) {
                const targetX = i % COLS;
                const targetY = Math.floor(i / COLS);
                
                const shapes = {
                    top: horizontalEdges[targetY][targetX],
                    right: verticalEdges[targetY][targetX+1],
                    bottom: horizontalEdges[targetY+1][targetX],
                    left: verticalEdges[targetY][targetX]
                };

                tempPieces.push({
                    id: i, targetX: targetX, targetY: targetY, currentX: -1, currentY: -1, 
                    isPlaced: false, shapes: shapes, el: null, groupEl: null, groupAnchorX: -1, groupAnchorY: -1,  
                });
            }

            shuffleArray(tempPieces);
            tempPieces.forEach(p => createPieceElement(p));
        }

        // --- SVG Path è¾…åŠ©å‡½æ•° (ä¿æŒä¸å˜) ---
        function getPiecePath(top, right, bottom, left) { 
            const S = TILE_SIZE; 
            const T = TAB_SIZE;
            let path = `M ${T} ${T} `; 
            if (top === 0) { path += `L ${T+S} ${T} `; } else { path += drawHorizontalSide(S, T, (top === -1) ? -1 : 1); }
            if (right === 0) { path += `L ${T+S} ${T+S} `; } else { path += drawVerticalSide(S, T, (right === 1) ? 1 : -1); }
            if (bottom === 0) { path += `L ${T} ${T+S} `; } else { path += drawHorizontalSideBack(S, T, (bottom === 1) ? 1 : -1); }
            if (left === 0) { path += `L ${T} ${T} `; } else { path += drawVerticalSideBack(S, T, (left === -1) ? -1 : 1); }
            return path + "Z";
        }
        function drawHorizontalSide(S, T, sign) { /* ä¿æŒä¸å˜ */ return `l ${S * 0.35} 0 c 5 ${sign*T}, ${S * 0.3 - 5} ${sign*T}, ${S * 0.3} 0 l ${S * 0.35} 0 `; }
        function drawHorizontalSideBack(S, T, sign) { /* ä¿æŒä¸å˜ */ return `l -${S * 0.35} 0 c -5 ${sign*T}, -${S * 0.3 - 5} ${sign*T}, -${S * 0.3} 0 l -${S * 0.35} 0 `; }
        function drawVerticalSide(S, T, sign) { /* ä¿æŒä¸å˜ */ return `l 0 ${S * 0.35} c ${sign*T} 5, ${sign*T} ${S * 0.3 - 5}, 0 ${S * 0.3} l 0 ${S * 0.35} `; }
        function drawVerticalSideBack(S, T, sign) { /* ä¿æŒä¸å˜ */ return `l 0 -${S * 0.35} c ${sign*T} -5, ${sign*T} -${S * 0.3 - 5}, 0 -${S * 0.3} l 0 -${S * 0.35} `; }


        function createPieceElement(pieceData) {
            const el = document.createElement('div');
            el.className = 'puzzle-piece';
            el.id = 'piece_' + pieceData.id;
            pieceData.el = el;
            
            el.style.backgroundImage = `url('${currentImgUrl}')`;
            
            const pathStr = getPiecePath(pieceData.shapes.top, pieceData.shapes.right, pieceData.shapes.bottom, pieceData.shapes.left);
            
            // **ä¿®æ­£ï¼šæ·»åŠ  -webkit-clip-path ä»¥ç¡®ä¿ Safari å…¼å®¹æ€§**
            el.style.clipPath = `path('${pathStr}')`;
            el.style.webkitClipPath = `path('${pathStr}')`;

            const bgX = -(pieceData.targetX * TILE_SIZE) + TAB_SIZE;
            const bgY = -(pieceData.targetY * TILE_SIZE) + TAB_SIZE;
            el.style.backgroundPosition = `${bgX}px ${bgY}px`;

            el.onmousedown = el.ontouchstart = (e) => handleDragStart(e, el, pieceData);
            
            dockEl.appendChild(el);
            pieces.push({el: el, data: pieceData});
        }
        
        // --- æ‹–æ‹½æ ¸å¿ƒé€»è¾‘ ---
        let draggedEl = null;
        let dragOffset = {x:0, y:0};

        function getCoords(e) {
            if (e.touches && e.touches.length) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function handleDragStart(e, el, pieceData) {
            if (!isGaming) return;
            e.preventDefault(); 
            
            // **ä¿®æ­£ï¼šåœ¨ iOS/Safari ä¸Šç¦ç”¨ body çš„ user-selectï¼Œæé«˜æ‹–æ‹½æµç•…åº¦**
            document.body.style.webkitUserSelect = 'none';

            let elementToDrag = pieceData.isPlaced ? pieceData.groupEl : el;
            
            draggedEl = elementToDrag;
            draggedEl.classList.add('dragging');

            const rect = elementToDrag.getBoundingClientRect();
            const coords = getCoords(e);
            dragOffset.x = coords.x - rect.left;
            dragOffset.y = coords.y - rect.top;

            dragLayer.appendChild(elementToDrag); 

            elementToDrag.style.left = (coords.x - dragOffset.x) + 'px';
            elementToDrag.style.top = (coords.y - dragOffset.y) + 'px';

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchmove', onMouseMove, { passive: false }); 
            document.addEventListener('touchend', onMouseUp);
        }

        function onMouseMove(e) {
           e.preventDefault(); 
           if (!draggedEl) return;
           const coords = getCoords(e);
           draggedEl.style.left = (coords.x - dragOffset.x) + 'px';
           draggedEl.style.top = (coords.y - dragOffset.y) + 'px';
        }

        function onMouseUp(e) {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.removeEventListener('touchmove', onMouseMove);
            document.removeEventListener('touchend', onMouseUp);
            
            document.body.style.webkitUserSelect = 'auto'; // æ¢å¤é€‰æ‹©

            if (!draggedEl) return;
            draggedEl.classList.remove('dragging');

            const boardRect = boardEl.getBoundingClientRect();
            const elementRect = draggedEl.getBoundingClientRect();
            
            const isGroup = draggedEl.classList.contains('puzzle-group');
            
            let placementSuccessful = false;
            
            const boardRelativeLeft = elementRect.left - boardRect.left;
            const boardRelativeTop = elementRect.top - boardRect.top;
            
            const anchorGridLeft = boardRelativeLeft - GROUP_OFFSET; 
            const anchorGridTop = boardRelativeTop - GROUP_OFFSET;
            
            const snapX = Math.round(anchorGridLeft / TILE_SIZE);
            const snapY = Math.round(anchorGridTop / TILE_SIZE);

            if (snapX >= 0 && snapX < COLS && snapY >= 0 && snapY < ROWS) {
                
                if (isGroup) {
                    
                    const anchorPiece = pieces.find(p => p.data.groupEl === draggedEl).data;
                    const piecesInGroup = pieces.filter(p => p.data.groupEl === draggedEl);

                    const offsetX = snapX - anchorPiece.groupAnchorX;
                    const offsetY = snapY - anchorPiece.groupAnchorY;

                    let collision = false;
                    let isWithinBounds = true;
                    
                    for (const p of piecesInGroup) {
                        const newPieceX = p.data.currentX + offsetX;
                        const newPieceY = p.data.currentY + offsetY;
                        
                        if (newPieceX < 0 || newPieceX >= COLS || newPieceY < 0 || newPieceY >= ROWS) {
                            isWithinBounds = false;
                            break;
                        }

                        const occupyingPiece = PLACED_PIECES_MAP.get(`${newPieceX},${newPieceY}`);

                        if (occupyingPiece && occupyingPiece.groupEl !== draggedEl) {
                            collision = true;
                            break;
                        }
                    }

                    if (isWithinBounds && !collision) {
                        placeGroup(draggedEl, snapX, snapY);
                        placementSuccessful = true;
                    }

                } else {
                    if (!PLACED_PIECES_MAP.has(`${snapX},${snapY}`)) {
                        const pieceObj = pieces.find(p => p.el === draggedEl).data;
                        placePiece(pieceObj, snapX, snapY);
                        placementSuccessful = true;
                    }
                }
            } 
            
            if (!placementSuccessful) {
                if (isGroup) {
                    const currentBoardX = elementRect.left - boardRect.left;
                    const currentBoardY = elementRect.top - boardRect.top;

                    draggedEl.style.transition = 'none';
                    boardEl.appendChild(draggedEl); 
                    draggedEl.style.left = currentBoardX + 'px';
                    draggedEl.style.top = currentBoardY + 'px';
                    
                    setTimeout(() => {
                        draggedEl.style.transition = 'all 1s ease-in-out';
                        returnGroupToPrevious(draggedEl);
                    }, 10);
                } else {
                    returnToDock(draggedEl);
                }
            }
            draggedEl = null;
        }

        // --- ç»„åˆæ‹¼å›¾å—é€»è¾‘ (ä¿æŒä¸å˜) ---
        function updatePieceMap(pieceObj, action) { /* ä¿æŒä¸å˜ */ }
        function createGroup(pieceObj) { /* ä¿æŒä¸å˜ */ }
        function movePieceToGroup(pieceObj, groupEl, anchorX, anchorY) { /* ä¿æŒä¸å˜ */ }
        function unionGroups(anchorGroupObj, targetGroupObj) { /* ä¿æŒä¸å˜ */ }
        function checkAndMergeByPosition(pieceObj) { /* ä¿æŒä¸å˜ */ }
        function checkExternalMerges(groupAnchorPiece) { /* ä¿æŒä¸å˜ */ }
        function placePiece(pieceObj, gridX, gridY) { /* ä¿æŒä¸å˜ */ }
        function placeGroup(groupEl, gridX, gridY) { /* ä¿æŒä¸å˜ */ }
        function returnToDock(el) { /* ä¿æŒä¸å˜ */ }
        function returnGroupToPrevious(groupEl) { /* ä¿æŒä¸å˜ */ }
        function updateTimer() { /* ä¿æŒä¸å˜ */ }
        function updateTimerView() { /* ä¿æŒä¸å˜ */ }
        function showOriginal() { overlayEl.classList.add('show'); }
        function hideOriginal() { overlayEl.classList.remove('show'); }
        function checkWin() { /* ä¿æŒä¸å˜ */ }
        function gameOver(success) { /* ä¿æŒä¸å˜ */ }
        function closeModal() { /* ä¿æŒä¸å˜ */ }
        function shuffleArray(array) { /* ä¿æŒä¸å˜ */ }

    </script>
</body>
</html>
