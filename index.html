<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ–°æ˜¥ç”»å· - ç§»åŠ¨ç«¯ä¼˜åŒ–ç‰ˆ</title>
    <style>
        :root {
            --primary-red: #8B0000;
            --gold: #FFD700;
            --bg-color: #2c2c2c;
            
            /* å˜é‡å°†åœ¨JSä¸­åŠ¨æ€è®¾ç½®ï¼Œè¿™é‡Œæ˜¯é»˜è®¤/å›é€€å€¼ */
            --tile-size: 80px; 
            --tab-size: 12px;
            --dock-width: 160px;
            
            --cols: 7;         
            --rows: 5;         
            --render-size: calc(var(--tile-size) + var(--tab-size) * 2);
            --board-w: calc(var(--cols) * var(--tile-size)); 
            --board-h: calc(var(--rows) * var(--tile-size));
        }

        body {
            font-family: 'Microsoft YaHei', serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px; /* è°ƒæ•´ padding é€‚åº”ç§»åŠ¨ç«¯ */
            min-height: 100vh;
            user-select: none; 
            overflow: auto; /* å…è®¸åœ¨å°å±å¹•ä¸Šæ»šåŠ¨ */
        }
        
        /* è°ƒæ•´å¸ƒå±€é€‚åº”å°å±å¹•ï¼Œå¿…è¦æ—¶å…è®¸æ¢è¡Œ */
        .game-container {
            display: flex; gap: 20px; 
            flex-direction: row; /* é»˜è®¤æ¨ªå‘å¸ƒå±€ */
            justify-content: center; 
            align-items: flex-start; 
            width: 100%;
            max-width: 900px;
        }

        /* é’ˆå¯¹å°å±å¹•è®¾å¤‡ï¼Œåˆ‡æ¢ä¸ºçºµå‘å¸ƒå±€ */
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
            }
            .puzzle-board {
                margin-bottom: 20px;
            }
            .piece-dock {
                /* åœ¨çºµå‘æ¨¡å¼ä¸‹ï¼ŒDockå¯ä»¥å æ®å¤§éƒ¨åˆ†å®½åº¦ */
                width: 95% !important; 
                max-height: 300px; /* é™åˆ¶é«˜åº¦ï¼Œé˜²æ­¢å æ®å¤ªå¤šå±å¹• */
                overflow-y: scroll;
                flex-direction: row; 
                flex-wrap: wrap; 
                justify-content: center;
                gap: 5px;
            }
        }

        #drag-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; 
            z-index: 9999;
        }

        /* é¡¶éƒ¨UIåŒº */
        .header {
            width: 100%; max-width: 900px; display: flex;
            justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, #4a1212, #2a0a0a);
            padding: 10px 10px; border: 2px solid var(--gold);
            border-radius: 10px; margin-bottom: 10px;
            box-sizing: border-box; flex-shrink: 0;
            font-size: 14px; /* è°ƒæ•´å­—ä½“å¤§å°é€‚åº”ç§»åŠ¨ç«¯ */
        }
        .title { font-size: 18px; }
        .status-bar { display: flex; gap: 10px; font-size: 14px; }
        .btn-group { display: flex; gap: 5px; }
        .btn { padding: 5px 10px; }
        #fileInput { display: none; }

        .puzzle-board {
            display: grid;
            grid-template-columns: repeat(var(--cols), var(--tile-size));
            grid-template-rows: repeat(var(--rows), var(--tile-size));
            gap: 0; 
            background-color: rgba(0, 0, 0, 0.5);
            border: 5px solid var(--gold);
            position: relative;
            width: var(--board-w);
            height: var(--board-h);
            flex-shrink: 0;
            z-index: 1;
            overflow: visible; 
            /* ç¡®ä¿åœ¨ç§»åŠ¨ç«¯ä¸ä¼šè¢«æˆªæ–­ */
            box-sizing: content-box; 
        }

        .grid-slot {
            width: var(--tile-size); height: var(--tile-size);
            border: 1px dashed rgba(255, 255, 255, 0.15); 
            box-sizing: border-box; pointer-events: none; 
            z-index: 2; 
        }

        .piece-dock {
            width: var(--dock-width); 
            height: calc(var(--board-h) + 10px);
            background: rgba(0,0,0,0.3); border: 2px solid #555;
            overflow-y: auto; padding: 5px; 
            display: flex;
            flex-direction: column; 
            align-items: center; 
            gap: 5px; 
            flex-shrink: 0; 
            z-index: 10;
        }

        .puzzle-piece {
            width: var(--render-size); height: var(--render-size);
            /* ä¼˜åŒ–è§¦æ‘¸ç›®æ ‡å¤§å° */
            touch-action: none; 
        }
        
        .flying-back {
            transition: all 1s ease-in-out !important; 
        }
    </style>
</head>
<body>

    <div id="drag-layer"></div>

    <div class="header">
        <div class="title">æ–°æ˜¥ç”»å· - ç§»åŠ¨ä¼˜åŒ–ç‰ˆ</div>
        <div class="status-bar">
            <span id="timerDisplay">â± 00:00</span>
            <span id="starDisplay">â­â­â­</span>
        </div>
        <div class="btn-group">
            <input type="file" id="fileInput" accept="image/*" onchange="handleImageUpload(event)">
            <button class="btn" onclick="document.getElementById('fileInput').click()">ğŸ“‚ é€‰æ‹©å›¾ç‰‡</button>
            <button class="btn" id="viewOriginalBtn" onmousedown="showOriginal()" onmouseup="hideOriginal()" onmouseleave="hideOriginal()" ontouchstart="showOriginal()" ontouchend="hideOriginal()">ğŸ‘€ åŸå›¾</button>
            <button class="btn" onclick="initGame()">ğŸ”„ é‡ç½®</button>
        </div>
    </div>

    <div class="game-container">
        <div class="puzzle-board" id="board">
            <div class="preview-overlay" id="previewOverlay"></div>
        </div>

        <div class="piece-dock" id="dock"></div>
    </div>

    <div class="modal" id="resultModal">
        <div class="modal-content">
            <h2 id="resultTitle">æŒ‘æˆ˜æˆåŠŸï¼</h2>
            <div class="star-result" id="resultStars">â­â­â­</div>
            <p id="resultTime">ç”¨æ—¶: 1åˆ†20ç§’</p>
            <p id="resultDesc">æ–°çºªå½•ï¼</p>
            <button class="btn" onclick="closeModal()">ç¡®å®š</button>
        </div>
    </div>

    <script>
        const COLS = 7; 
        const ROWS = 5; 
        
        let TILE_SIZE; // åŠ¨æ€è®¡ç®—çš„å°ºå¯¸
        let TAB_SIZE;
        let GROUP_OFFSET;
        
        const PLACED_PIECES_MAP = new Map(); 
        let currentImgUrl = './image.jpg'; 
        const FALLBACK_IMG = 'https://picsum.photos/560/400';

        let pieces = []; 
        let isGaming = false;
        let timerInterval = null;
        let secondsElapsed = 0;
        
        let verticalEdges = [];   
        let horizontalEdges = []; 

        const boardEl = document.getElementById('board');
        const dockEl = document.getElementById('dock');
        const dragLayer = document.getElementById('drag-layer');
        // ... (å…¶ä»– DOM å…ƒç´ )

        // **RWD æ ¸å¿ƒå‡½æ•°ï¼šæ ¹æ®å±å¹•å°ºå¯¸åŠ¨æ€è®¡ç®— TILE_SIZE**
        function setupResponsiveSizes() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            
            let dynamicTileSize;

            // æ£€æŸ¥æ˜¯å¦æ˜¯å°å±å¹•ï¼ˆå¦‚æ‰‹æœºçºµå‘ï¼‰
            if (vw < 768 || vw < vh) {
                // çºµå‘/å°å±å¹•ï¼šè®©æ£‹ç›˜å æ® 95% çš„å®½åº¦
                dynamicTileSize = Math.floor((vw * 0.95) / COLS);
            } else {
                // æ¨ªå‘/å¤§å±å¹•ï¼šè®©æ£‹ç›˜å æ®ä¸è¶…è¿‡ 75% çš„å®½åº¦ï¼Œå¹¶é™åˆ¶æœ€å¤§å°ºå¯¸
                dynamicTileSize = Math.floor((vw * 0.75) / COLS);
            }
            
            // é™åˆ¶æœ€å¤§å°ºå¯¸ä¸ºæ¡Œé¢å‹å¥½å°ºå¯¸ï¼Œé˜²æ­¢åœ¨è¶…å¤§å±å¹•ä¸Šå¤±æ§
            const MAX_TILE_SIZE = 80;
            dynamicTileSize = Math.min(MAX_TILE_SIZE, dynamicTileSize);

            // æ›´æ–°å…¨å±€å˜é‡
            TILE_SIZE = dynamicTileSize;
            TAB_SIZE = Math.round(TILE_SIZE * 0.15); 
            GROUP_OFFSET = -TAB_SIZE;
            
            // å³ä¾§ Dock çš„å®½åº¦è®¾ç½®ä¸ºä¸¤ä¸ªç¢ç‰‡å®½
            const DOCK_WIDTH = (TILE_SIZE + 2 * TAB_SIZE) * 2;

            // åº”ç”¨å°ºå¯¸åˆ° CSS å˜é‡
            document.documentElement.style.setProperty('--tile-size', TILE_SIZE + 'px');
            document.documentElement.style.setProperty('--tab-size', TAB_SIZE + 'px');
            document.documentElement.style.setProperty('--dock-width', DOCK_WIDTH + 'px');
        }

        window.onload = () => {
            setupResponsiveSizes();
            checkDefaultImage();
            createGrid();
        };

        window.onresize = () => {
             // é‡æ–°è®¡ç®—å°ºå¯¸å¹¶åˆ·æ–°å¸ƒå±€ï¼Œä¿è¯ RWD æ•ˆæœ
             setupResponsiveSizes();
             // é‡æ–°åˆå§‹åŒ–æ¸¸æˆä»¥åº”ç”¨æ–°çš„å°ºå¯¸ï¼ˆè™½ç„¶ä¼šä¸¢å¤±è¿›åº¦ï¼Œä½†åœ¨ demo ä¸­æ˜¯åˆç†çš„ï¼‰
             if (isGaming) {
                 initGame();
             } else {
                 createGrid(); // è‡³å°‘åˆ·æ–°æ£‹ç›˜å¸ƒå±€
             }
        };
        
        // ... (å…¶ä»–è¾…åŠ©å‡½æ•°ï¼Œå¦‚ checkDefaultImage, handleImageUpload, createGrid, generatePuzzleShapes, getPiecePath, drawHorizontalSide, drawVerticalSideç­‰ä¿æŒä¸å˜)
        
        function createGrid() {
            boardEl.innerHTML = '';
            boardEl.appendChild(overlayEl); 
            // ç¡®ä¿ CSS å˜é‡å·²æ›´æ–°ï¼Œè®©æ£‹ç›˜å°ºå¯¸æ­£ç¡®æ¸²æŸ“
            boardEl.style.width = `var(--board-w)`;
            boardEl.style.height = `var(--board-h)`;
            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    let slot = document.createElement('div');
                    slot.className = 'grid-slot';
                    boardEl.appendChild(slot);
                }
            }
        }
        
        // --- æ‹–æ‹½æ ¸å¿ƒé€»è¾‘ (å·²ä¿®æ”¹ä¸ºæ”¯æŒ Touch äº‹ä»¶) ---
        let draggedEl = null;
        let dragOffset = {x:0, y:0};

        // è¾…åŠ©å‡½æ•°ï¼šè·å–é¼ æ ‡æˆ–è§¦æ‘¸åæ ‡
        function getCoords(e) {
            if (e.touches && e.touches.length) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }


        function handleDragStart(e, el, pieceData) {
            if (!isGaming) return;
            e.preventDefault(); 
            
            let elementToDrag = pieceData.isPlaced ? pieceData.groupEl : el;
            
            draggedEl = elementToDrag;
            draggedEl.classList.add('dragging');

            const rect = elementToDrag.getBoundingClientRect();
            const coords = getCoords(e);
            dragOffset.x = coords.x - rect.left;
            dragOffset.y = coords.y - rect.top;

            dragLayer.appendChild(elementToDrag); 

            elementToDrag.style.left = (coords.x - dragOffset.x) + 'px';
            elementToDrag.style.top = (coords.y - dragOffset.y) + 'px';

            // æ³¨å†Œé¼ æ ‡å’Œè§¦æ‘¸äº‹ä»¶
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('touchmove', onMouseMove, { passive: false }); 
            document.addEventListener('touchend', onMouseUp);
        }

        function onMouseMove(e) {
           e.preventDefault(); 
           if (!draggedEl) return;
           const coords = getCoords(e);
           draggedEl.style.left = (coords.x - dragOffset.x) + 'px';
           draggedEl.style.top = (coords.y - dragOffset.y) + 'px';
        }

        function onMouseUp(e) {
            // å–æ¶ˆæ³¨å†Œé¼ æ ‡å’Œè§¦æ‘¸äº‹ä»¶
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
            document.removeEventListener('touchmove', onMouseMove);
            document.removeEventListener('touchend', onMouseUp);
            
            if (!draggedEl) return;
            draggedEl.classList.remove('dragging');

            const boardRect = boardEl.getBoundingClientRect();
            const elementRect = draggedEl.getBoundingClientRect();
            
            const isGroup = draggedEl.classList.contains('puzzle-group');
            
            let placementSuccessful = false;
            
            // æ ¸å¿ƒå¸é™„é€»è¾‘ï¼ˆä½¿ç”¨åŠ¨æ€ TILE_SIZEï¼‰
            const boardRelativeLeft = elementRect.left - boardRect.left;
            const boardRelativeTop = elementRect.top - boardRect.top;
            
            const anchorGridLeft = boardRelativeLeft - GROUP_OFFSET; 
            const anchorGridTop = boardRelativeTop - GROUP_OFFSET;
            
            const snapX = Math.round(anchorGridLeft / TILE_SIZE);
            const snapY = Math.round(anchorGridTop / TILE_SIZE);

            if (snapX >= 0 && snapX < COLS && snapY >= 0 && snapY < ROWS) {
                
                if (isGroup) {
                    
                    const anchorPiece = pieces.find(p => p.data.groupEl === draggedEl).data;
                    const piecesInGroup = pieces.filter(p => p.data.groupEl === draggedEl);

                    const offsetX = snapX - anchorPiece.groupAnchorX;
                    const offsetY = snapY - anchorPiece.groupAnchorY;

                    let collision = false;
                    let isWithinBounds = true;
                    
                    for (const p of piecesInGroup) {
                        const newPieceX = p.data.currentX + offsetX;
                        const newPieceY = p.data.currentY + offsetY;
                        
                        if (newPieceX < 0 || newPieceX >= COLS || newPieceY < 0 || newPieceY >= ROWS) {
                            isWithinBounds = false;
                            break;
                        }

                        const occupyingPiece = PLACED_PIECES_MAP.get(`${newPieceX},${newPieceY}`);

                        if (occupyingPiece && occupyingPiece.groupEl !== draggedEl) {
                            collision = true;
                            break;
                        }
                    }

                    if (isWithinBounds && !collision) {
                        placeGroup(draggedEl, snapX, snapY);
                        placementSuccessful = true;
                    }

                } else {
                    if (!PLACED_PIECES_MAP.has(`${snapX},${snapY}`)) {
                        const pieceObj = pieces.find(p => p.el === draggedEl).data;
                        placePiece(pieceObj, snapX, snapY);
                        placementSuccessful = true;
                    }
                }
            } 
            
            // æ”¾ç½®å¤±è´¥å¤„ç†
            if (!placementSuccessful) {
                if (isGroup) {
                    const currentBoardX = elementRect.left - boardRect.left;
                    const currentBoardY = elementRect.top - boardRect.top;

                    draggedEl.style.transition = 'none';
                    boardEl.appendChild(draggedEl); 
                    draggedEl.style.left = currentBoardX + 'px';
                    draggedEl.style.top = currentBoardY + 'px';
                    
                    setTimeout(() => {
                        draggedEl.style.transition = 'all 1s ease-in-out';
                        returnGroupToPrevious(draggedEl);
                    }, 10);
                } else {
                    returnToDock(draggedEl);
                }
            }
            draggedEl = null;
        }

        // --- ä»¥ä¸‹å‡½æ•°ä¸»è¦ä¸ºæ•°æ®å’ŒåŠ¨ç”»é€»è¾‘ï¼Œç»´æŒä¸å˜ï¼Œä½†ä¾èµ– TILE_SIZE, TAB_SIZE, GROUP_OFFSET çš„åŠ¨æ€å€¼ ---

        function createPieceElement(pieceData) {
            const el = document.createElement('div');
            el.className = 'puzzle-piece';
            el.id = 'piece_' + pieceData.id;
            pieceData.el = el;
            
            el.style.backgroundImage = `url('${currentImgUrl}')`;
            
            // SVG Path ä¾èµ– TAB_SIZE å’Œ TILE_SIZE
            const pathStr = getPiecePath(pieceData.shapes.top, pieceData.shapes.right, pieceData.shapes.bottom, pieceData.shapes.left);
            el.style.clipPath = `path('${pathStr}')`;
            el.style.webkitClipPath = `path('${pathStr}')`;

            const bgX = -(pieceData.targetX * TILE_SIZE) + TAB_SIZE;
            const bgY = -(pieceData.targetY * TILE_SIZE) + TAB_SIZE;
            el.style.backgroundPosition = `${bgX}px ${bgY}px`;

            // ç»‘å®šé¼ æ ‡å’Œè§¦æ‘¸äº‹ä»¶
            el.onmousedown = el.ontouchstart = (e) => handleDragStart(e, el, pieceData);
            
            dockEl.appendChild(el);
            pieces.push({el: el, data: pieceData});
        }
        
        function placePiece(pieceObj, gridX, gridY) {
            updatePieceMap(pieceObj, 'remove'); 
            pieceObj.isPlaced = true;
            pieceObj.currentX = gridX;
            pieceObj.currentY = gridY;
            updatePieceMap(pieceObj, 'add');
            createGroup(pieceObj);
            checkAndMergeByPosition(pieceObj);
        }
        
        function placeGroup(groupEl, gridX, gridY) {
            const anchorPiece = pieces.find(p => p.data.groupEl === groupEl).data;
            const piecesInGroup = pieces.filter(p => p.data.groupEl === groupEl);
            piecesInGroup.forEach(p => updatePieceMap(p.data, 'remove')); 

            const offsetX = gridX - anchorPiece.groupAnchorX;
            const offsetY = gridY - anchorPiece.groupAnchorY;
            
            piecesInGroup.forEach(p => {
                p.data.currentX = p.data.currentX + offsetX;
                p.data.currentY = p.data.currentY + offsetY;
                p.data.isPlaced = true;
                
                if (p.data === anchorPiece) {
                    p.data.groupAnchorX = gridX;
                    p.data.groupAnchorY = gridY;
                }
                updatePieceMap(p.data, 'add'); 
            });
            
            boardEl.appendChild(groupEl); 

            groupEl.style.left = (anchorPiece.groupAnchorX * TILE_SIZE + GROUP_OFFSET) + 'px';
            groupEl.style.top = (anchorPiece.groupAnchorY * TILE_SIZE + GROUP_OFFSET) + 'px';
            
            checkExternalMerges(anchorPiece);
            checkWin();
        }

        // SVG Path å‡½æ•° (ä¿æŒä¸å˜ï¼Œä½†ä¾èµ–åŠ¨æ€ TILE_SIZE å’Œ TAB_SIZE)
        function getPiecePath(top, right, bottom, left) { 
            const S = TILE_SIZE; 
            const T = TAB_SIZE;
            let path = `M ${T} ${T} `; 
            // ... (è·¯å¾„è®¡ç®—é€»è¾‘) ...
            if (top === 0) { path += `L ${T+S} ${T} `; } else { path += drawHorizontalSide(S, T, (top === -1) ? -1 : 1); }
            if (right === 0) { path += `L ${T+S} ${T+S} `; } else { path += drawVerticalSide(S, T, (right === 1) ? 1 : -1); }
            if (bottom === 0) { path += `L ${T} ${T+S} `; } else { path += drawHorizontalSideBack(S, T, (bottom === 1) ? 1 : -1); }
            if (left === 0) { path += `L ${T} ${T} `; } else { path += drawVerticalSideBack(S, T, (left === -1) ? -1 : 1); }
            return path + "Z";
        }
        
        function drawHorizontalSide(S, T, sign) { 
            const neck = S * 0.35; const earW = S * 0.3; 
            let p = `l ${neck} 0 `; 
            p += `c 5 ${sign*T}, ${earW-5} ${sign*T}, ${earW} 0 `; 
            p += `l ${neck} 0 `; return p; 
        }
        function drawHorizontalSideBack(S, T, sign) { 
            const neck = S * 0.35; const earW = S * 0.3; 
            let p = `l -${neck} 0 `; 
            p += `c -5 ${sign*T}, -${earW-5} ${sign*T}, -${earW} 0 `; 
            p += `l -${neck} 0 `; return p; 
        }
        function drawVerticalSide(S, T, sign) { 
            const neck = S * 0.35; const earW = S * 0.3; 
            let p = `l 0 ${neck} `; 
            p += `c ${sign*T} 5, ${sign*T} ${earW-5}, 0 ${earW} `; 
            p += `l 0 ${neck} `; return p; 
        }
        
        function drawVerticalSideBack(S, T, sign) {
            const neck = S * 0.35;
            const earW = S * 0.3;
            let p = `l 0 -${neck} `; 
            p += `c ${sign*T} -5, ${sign*T} -${earW-5}, 0 -${earW} `; 
            p += `l 0 -${neck} `; 
            return p;
        }

        function returnToDock(el) {
            const id = parseInt(el.id.split('_')[1]);
            const pieceObj = pieces.find(p => p.data.id === id).data;
            
            updatePieceMap(pieceObj, 'remove');
            pieceObj.isPlaced = false;

            const currentRect = el.getBoundingClientRect(); 
            const placeholder = document.createElement('div');
            placeholder.style.width = el.offsetWidth + 'px';
            placeholder.style.height = el.offsetHeight + 'px';
            placeholder.style.visibility = 'hidden'; 
            
            // æ’å…¥å ä½ç¬¦ä»¥ç¡®å®šç›®æ ‡ä½ç½®
            dockEl.appendChild(placeholder); 
            const targetRect = placeholder.getBoundingClientRect(); 

            el.style.transition = 'none'; 
            el.style.position = 'absolute'; 
            el.style.left = currentRect.left + 'px';
            el.style.top = currentRect.top + 'px';
            dragLayer.appendChild(el);
            
            setTimeout(() => {
                el.style.transition = 'all 1s ease-in-out'; 
                el.classList.add('flying-back');
                el.style.left = targetRect.left + 'px';
                el.style.top = targetRect.top + 'px';
            }, 10); 

            setTimeout(() => {
                el.classList.remove('flying-back');
                el.style.transition = 'none'; 
                
                dockEl.insertBefore(el, placeholder);
                placeholder.remove();

                el.style.position = 'relative';
                el.style.left = '0';
                el.style.top = '0';
            }, 1000); 
        }
        
        function returnGroupToPrevious(groupEl) {
            const anchorPiece = pieces.find(p => p.data.groupEl === groupEl).data;
            const prevX = anchorPiece.groupAnchorX;
            const prevY = anchorPiece.groupAnchorY; 

            groupEl.classList.add('flying-back'); 
            
            groupEl.style.left = (prevX * TILE_SIZE + GROUP_OFFSET) + 'px';
            groupEl.style.top = (prevY * TILE_SIZE + GROUP_OFFSET) + 'px';

            setTimeout(() => {
                groupEl.classList.remove('flying-back');
                groupEl.style.transition = 'none'; 
            }, 1000);
        }

        // ... (checkAndMergeByPosition, checkExternalMerges, initGame, updateTimer, checkWin, gameOver, closeModal, shuffleArray ç­‰å…¶ä»–å‡½æ•°ä¿æŒä¸å˜)

        function updatePieceMap(pieceObj, action) { /* ä¿æŒä¸å˜ */ }
        function createGroup(pieceObj) { /* ä¿æŒä¸å˜ */ }
        function movePieceToGroup(pieceObj, groupEl, anchorX, anchorY) { /* ä¿æŒä¸å˜ */ }
        function unionGroups(anchorGroupObj, targetGroupObj) { /* ä¿æŒä¸å˜ */ }
        function checkAndMergeByPosition(pieceObj) { /* ä¿æŒä¸å˜ */ }
        function checkExternalMerges(groupAnchorPiece) { /* ä¿æŒä¸å˜ */ }
        function initGame() {
             isGaming = true;
            secondsElapsed = 0;
            pieces = [];
            PLACED_PIECES_MAP.clear();
            
            overlayEl.style.backgroundImage = `url('${currentImgUrl}')`;
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
            updateTimerView();

            dockEl.innerHTML = '';
            document.querySelectorAll('.puzzle-piece, .puzzle-group').forEach(p => p.remove());

            generatePuzzleShapes();

            let tempPieces = [];
            const TOTAL_PIECES = COLS * ROWS; 
            for (let i = 0; i < TOTAL_PIECES; i++) {
                const targetX = i % COLS;
                const targetY = Math.floor(i / COLS);
                
                const shapes = {
                    top: horizontalEdges[targetY][targetX],
                    right: verticalEdges[targetY][targetX+1],
                    bottom: horizontalEdges[targetY+1][targetX],
                    left: verticalEdges[targetY][targetX]
                };

                tempPieces.push({
                    id: i,
                    targetX: targetX,
                    targetY: targetY,
                    currentX: -1, 
                    currentY: -1, 
                    isPlaced: false,
                    shapes: shapes,
                    el: null,          
                    groupEl: null,     
                    groupAnchorX: -1,  
                    groupAnchorY: -1,  
                });
            }

            shuffleArray(tempPieces);
            tempPieces.forEach(p => createPieceElement(p));
        }
        function updateTimer() { /* ä¿æŒä¸å˜ */ }
        function updateTimerView() { /* ä¿æŒä¸å˜ */ }
        function showOriginal() { overlayEl.classList.add('show'); }
        function hideOriginal() { overlayEl.classList.remove('show'); }
        function checkWin() { /* ä¿æŒä¸å˜ */ }
        function gameOver(success) { /* ä¿æŒä¸å˜ */ }
        function closeModal() { /* ä¿æŒä¸å˜ */ }
        function shuffleArray(array) { /* ä¿æŒä¸å˜ */ }
    </script>
</body>
</html>
